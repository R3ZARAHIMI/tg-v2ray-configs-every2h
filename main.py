# -*- coding: utf-8 -*-

import re
import asyncio
import base64
import json
import yaml
import os
import uuid
from urllib.parse import urlparse, parse_qs, unquote

# Pyrogram imports
from pyrogram import Client
from pyrogram.errors import FloodWait

# =================================================================================
# Ø¨Ø®Ø´ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ùˆ Ø®ÙˆØ§Ù†Ø¯Ù† Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ Ø§Ø² Ù…Ø­ÛŒØ·
# =================================================================================

# --- Ø®ÙˆØ§Ù†Ø¯Ù† Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ Ù¾Ø§ÛŒØ±ÙˆÚ¯Ø±Ø§Ù… ---
# Ø§Ú¯Ø± Ø§ÛŒÙ† Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ù†Ø¯ØŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¨Ø§ Ø®Ø·Ø§ Ù…ØªÙˆÙ‚Ù Ù…ÛŒâ€ŒØ´ÙˆØ¯.
try:
    API_ID = int(os.environ.get("API_ID"))
except (ValueError, TypeError):
    print("âŒ Ø®Ø·Ø§: Ø³Ú©Ø±Øª API_ID ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ ÛŒØ§ Ù…Ù‚Ø¯Ø§Ø± Ø¢Ù† Ø¹Ø¯Ø¯ ØµØ­ÛŒØ­ Ù†ÛŒØ³Øª.")
    exit(1)

API_HASH = os.environ.get("API_HASH")
SESSION_STRING = os.environ.get("SESSION_STRING")

# --- Ø®ÙˆØ§Ù†Ø¯Ù† Ù„ÛŒØ³Øª Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§ Ùˆ Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ Ø§Ø² Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ ---
CHANNELS_STR = os.environ.get('CHANNELS_LIST')
GROUPS_STR = os.environ.get('GROUPS_LIST')

# --- Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ùˆ Ù†Ø§Ù… ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø®Ø±ÙˆØ¬ÛŒ ---
CHANNEL_SEARCH_LIMIT = 50   # ØªØ¹Ø¯Ø§Ø¯ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø¢Ø®Ø± Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„â€ŒÙ‡Ø§
GROUP_SEARCH_LIMIT = 600    # ØªØ¹Ø¯Ø§Ø¯ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø¢Ø®Ø± Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§
OUTPUT_YAML = "configs.yaml" # Ù†Ø§Ù… ÙØ§ÛŒÙ„ Ø®Ø±ÙˆØ¬ÛŒ YAML Ø¨Ø±Ø§ÛŒ Clash
OUTPUT_TXT = "configs.txt"     # Ù†Ø§Ù… ÙØ§ÛŒÙ„ Ø®Ø±ÙˆØ¬ÛŒ Ù…ØªÙ†ÛŒ Ø¨Ø§ Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ù…

# =================================================================================
# ØªÙˆØ§Ø¨Ø¹ Ùˆ Ú©Ù„Ø§Ø³â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡
# =================================================================================

def process_lists():
    """Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡ Ø§Ø² Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ù‡ Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒØªÙˆÙ† ØªØ¨Ø¯ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
    channels = [ch.strip() for ch in CHANNELS_STR.split(',')] if CHANNELS_STR else []
    if channels:
        print(f"âœ… {len(channels)} Ú©Ø§Ù†Ø§Ù„ Ø§Ø² Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯.")
    else:
        print("âš ï¸ Ù‡Ø´Ø¯Ø§Ø±: Ø³Ú©Ø±Øª CHANNELS_LIST Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ ÛŒØ§ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª.")
    
    groups = []
    if GROUPS_STR:
        try:
            # Ø¢ÛŒØ¯ÛŒ Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ Ø¨Ø§ÛŒØ¯ Ø¹Ø¯Ø¯ÛŒ Ø¨Ø§Ø´Ø¯
            groups = [int(g.strip()) for g in GROUPS_STR.split(',')]
            print(f"âœ… {len(groups)} Ú¯Ø±ÙˆÙ‡ Ø§Ø² Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ Ø®ÙˆØ§Ù†Ø¯Ù‡ Ø´Ø¯.")
        except ValueError:
            print("âŒ Ø®Ø·Ø§: Ø³Ú©Ø±Øª GROUPS_LIST Ø¨Ø§ÛŒØ¯ ÙÙ‚Ø· Ø´Ø§Ù…Ù„ Ø¢ÛŒØ¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¹Ø¯Ø¯ÛŒ Ø¨Ø§Ø´Ø¯.")
    else:
        print("âš ï¸ Ù‡Ø´Ø¯Ø§Ø±: Ø³Ú©Ø±Øª GROUPS_LIST Ø®Ø§Ù„ÛŒ Ø§Ø³Øª.")
        
    return channels, groups

CHANNELS, GROUPS = process_lists()

# Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ Regex Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø§Ù†ÙˆØ§Ø¹ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§
V2RAY_PATTERNS = [
    re.compile(r'(vless:\/\/[^\s\'\"<>`]+)'),
    re.compile(r'(vmess:\/\/[^\s\'\"<>`]+)'),
    re.compile(r'(trojan:\/\/[^\s\'\"<>`]+)'),
    # re.compile(r'(ss:\/\/[^\s\'\"<>`]+)'), # Shadowsocks ÙØ¹Ù„Ø§ ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª
    re.compile(r"(hy2://[^\s'\"<>`]+)"),
    re.compile(r"(hysteria2://[^\s'\"<>`]+)"),
    re.compile(r"(tuic://[^\s'\"<>`]+)")
]

# Ø§Ù„Ú¯ÙˆÛŒ Regex Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ Ø·ÙˆÙ„Ø§Ù†ÛŒ Base64
BASE64_PATTERN = re.compile(r"([A-Za-z0-9+/=]{50,})", re.MULTILINE)


class V2RayExtractor:
    """Ú©Ù„Ø§Ø³ Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ùˆ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ V2Ray."""
    def __init__(self):
        self.raw_configs = set()
        self.client = Client(
            "my_account",
            api_id=API_ID,
            api_hash=API_HASH,
            session_string=SESSION_STRING
        )

    @staticmethod
    def _generate_unique_name(original_name, prefix="config"):
        """ÛŒÚ© Ù†Ø§Ù… Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ú©Ø§Ù†ÙÛŒÚ¯ ØªÙˆÙ„ÛŒØ¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
        # Ø§Ú¯Ø± Ù†Ø§Ù… Ø§ØµÙ„ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø´ØªØŒ ÛŒÚ© Ù†Ø§Ù… Ú©Ø§Ù…Ù„Ø§ ØªØµØ§Ø¯ÙÛŒ Ø¨Ø³Ø§Ø²
        if not original_name:
            return f"{prefix}-{str(uuid.uuid4())[:8]}"
        
        # Ø­Ø°Ù Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ ØºÛŒØ±Ù…Ø¬Ø§Ø² Ùˆ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ ÙØ§ØµÙ„Ù‡ Ø¨Ø§ Ø¢Ù†Ø¯Ø±Ù„Ø§ÛŒÙ†
        # Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² Ø­Ø±ÙˆÙ ÙØ§Ø±Ø³ÛŒ Ø¯Ø± Ù†Ø§Ù…
        cleaned_name = re.sub(r'[^\w\s\-\_\u0600-\u06FF]', '', original_name).replace(' ', '_').strip('_-')
        
        # Ø§Ú¯Ø± Ø¨Ø¹Ø¯ Ø§Ø² Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ú†ÛŒØ²ÛŒ Ø¨Ø§Ù‚ÛŒ Ù†Ù…Ø§Ù†Ø¯ØŒ ÛŒÚ© Ù†Ø§Ù… ØªØµØ§Ø¯ÙÛŒ Ø¨Ø¯Ù‡
        if not cleaned_name:
            return f"{prefix}-{str(uuid.uuid4())[:8]}"
            
        return f"{cleaned_name}-{str(uuid.uuid4())[:4]}" # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¨Ø®Ø´ ØªØµØ§Ø¯ÙÛŒ Ú©ÙˆÚ†Ú© Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ØªÚ©Ø±Ø§Ø±

    def parse_config_for_clash(self, config_url):
        """Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø±Ø§ÛŒ ÙØ±Ù…Øª Clash Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
        try:
            if config_url.startswith('vmess://'): return self.parse_vmess(config_url)
            if config_url.startswith('vless://'): return self.parse_vless(config_url)
            if config_url.startswith('trojan://'): return self.parse_trojan(config_url)
            return None
        except Exception:
            # Ø¯Ø± ØµÙˆØ±Øª Ø¨Ø±ÙˆØ² Ù‡Ø±Ú¯ÙˆÙ†Ù‡ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÛŒÚ© Ú©Ø§Ù†ÙÛŒÚ¯ØŒ Ø¢Ù† Ø±Ø§ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ø¯
            return None

    def parse_vmess(self, vmess_url):
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Vmess."""
        parts = vmess_url.split("://")
        encoded_data = parts[1]
        
        try:
            # Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² Ø§ÛŒÙ†Ú©Ù‡ Ø·ÙˆÙ„ Ø±Ø´ØªÙ‡ Ø¨Ø±Ø§ÛŒ base64 Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª
            decoded_str = base64.b64decode(encoded_data + '=' * (-len(encoded_data) % 4)).decode('utf-8')
            config = json.loads(decoded_str)
        except (json.JSONDecodeError, base64.binascii.Error):
            return None

        original_name = config.get('ps', '')
        
        # Ø³Ø§Ø®Øª ws-opts ÙÙ‚Ø· Ø¯Ø± ØµÙˆØ±ØªÛŒ Ú©Ù‡ network Ø§Ø² Ù†ÙˆØ¹ ws Ø¨Ø§Ø´Ø¯
        ws_opts = None
        if config.get('net') == 'ws':
            host_header = config.get('host', '').strip() or config.get('add', '').strip()
            if host_header:
                ws_opts = {
                    'path': config.get('path', '/'),
                    'headers': {'Host': host_header}
                }

        return {
            'name': self._generate_unique_name(original_name, "vmess"), 'type': 'vmess',
            'server': config.get('add'), 'port': int(config.get('port', 443)),
            'uuid': config.get('id'), 'alterId': int(config.get('aid', 0)),
            'cipher': config.get('scy', 'auto'), 'tls': config.get('tls') == 'tls',
            'network': config.get('net', 'tcp'), 'udp': True,
            'ws-opts': ws_opts
        }

    def parse_vless(self, vless_url):
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Vless."""
        parsed = urlparse(vless_url)
        query = parse_qs(parsed.query)
        original_name = unquote(parsed.fragment) if parsed.fragment else ''
        
        # Ø³Ø§Ø®Øª ws-opts ÙÙ‚Ø· Ø¯Ø± ØµÙˆØ±ØªÛŒ Ú©Ù‡ network Ø§Ø² Ù†ÙˆØ¹ ws Ø¨Ø§Ø´Ø¯
        ws_opts = None
        if query.get('type', [''])[0] == 'ws':
            host_header = query.get('host', [''])[0].strip() or query.get('sni', [''])[0].strip() or parsed.hostname
            if host_header:
                ws_opts = {
                    'path': query.get('path', ['/'])[0],
                    'headers': {'Host': host_header}
                }

        # Ø³Ø§Ø®Øª reality-opts ÙÙ‚Ø· Ø¯Ø± ØµÙˆØ±ØªÛŒ Ú©Ù‡ security Ø§Ø² Ù†ÙˆØ¹ reality Ø¨Ø§Ø´Ø¯
        reality_opts = None
        if query.get('security', [''])[0] == 'reality':
            pbk = query.get('pbk', [None])[0]
            if pbk:
                reality_opts = {'public-key': pbk, 'short-id': query.get('sid', [''])[0]}

        return {
            'name': self._generate_unique_name(original_name, "vless"), 'type': 'vless',
            'server': parsed.hostname, 'port': parsed.port or 443,
            'uuid': parsed.username, 'udp': True, 'tls': query.get('security', [''])[0] in ['tls', 'reality'],
            'network': query.get('type', ['tcp'])[0], 'servername': query.get('sni', [None])[0],
            'ws-opts': ws_opts,
            'reality-opts': reality_opts
        }

    def parse_trojan(self, trojan_url):
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Trojan."""
        parsed = urlparse(trojan_url)
        query = parse_qs(parsed.query)
        original_name = unquote(parsed.fragment) if parsed.fragment else ''
        
        # Ø¨Ø±Ø§ÛŒ ØªØ±ÙˆØ¬Ø§Ù†ØŒ sni Ø§Ø² Ù¾Ø§Ø±Ø§Ù…ØªØ± peer ÛŒØ§ sni Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
        sni = query.get('peer', [None])[0] or query.get('sni', [None])[0] or parsed.hostname
        
        return {
            'name': self._generate_unique_name(original_name, "trojan"), 'type': 'trojan',
            'server': parsed.hostname, 'port': parsed.port or 443,
            'password': parsed.username, 'udp': True, 'sni': sni
        }

    async def find_raw_configs_from_chat(self, chat_id, limit):
        """Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ø² ÛŒÚ© Ú†Øª Ù…Ø´Ø®Øµ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
        try:
            print(f"ğŸ” Ø¬Ø³ØªØ¬Ùˆ Ø¯Ø± Ú†Øª {chat_id} (Ù…Ø­Ø¯ÙˆØ¯ÛŒØª: {limit} Ù¾ÛŒØ§Ù…)...")
            async for message in self.client.get_chat_history(chat_id, limit=limit):
                if not message.text: continue
                
                texts_to_scan = [message.text]
                # ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø¯ÛŒÚ©Ø¯ Ú©Ø±Ø¯Ù† Ø±Ø´ØªÙ‡â€ŒÙ‡Ø§ÛŒ Base64 Ø¨Ø±Ø§ÛŒ Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Ù…Ø®ÙÛŒ
                potential_b64 = BASE64_PATTERN.findall(message.text)
                for b64_str in potential_b64:
                    try:
                        decoded_text = base64.b64decode(b64_str + '=' * (-len(b64_str) % 4)).decode('utf-8', errors='ignore')
                        texts_to_scan.append(decoded_text)
                    except Exception:
                        continue
                
                # Ø¬Ø³ØªØ¬ÙˆÛŒ Ø§Ù„Ú¯ÙˆÙ‡Ø§ÛŒ V2Ray Ø¯Ø± Ù…ØªÙ† Ø§ØµÙ„ÛŒ Ùˆ Ù…ØªÙ†â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒÚ©Ø¯ Ø´Ø¯Ù‡
                for text in texts_to_scan:
                    for pattern in V2RAY_PATTERNS:
                        found_configs = pattern.findall(text)
                        # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² set Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø°Ø®ÛŒØ±Ù‡ Ú©Ø§Ù†ÙÛŒÚ¯ ØªÚ©Ø±Ø§Ø±ÛŒ
                        self.raw_configs.update(m.strip() for m in found_configs)
                        
        except FloodWait as e:
            print(f"â³ Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª ØªÙ„Ú¯Ø±Ø§Ù…ØŒ Ø¨Ø±Ø§ÛŒ Ú†Øª {chat_id} Ø¨Ù‡ Ù…Ø¯Øª {e.value} Ø«Ø§Ù†ÛŒÙ‡ ØµØ¨Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ….")
            await asyncio.sleep(e.value)
            await self.find_raw_configs_from_chat(chat_id, limit) # ØªÙ„Ø§Ø´ Ù…Ø¬Ø¯Ø¯
        except Exception as e:
            print(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø²Ù…Ø§Ù† Ø§Ø³Ú©Ù† Ú†Øª {chat_id}: {e}")

    def save_files(self):
        """ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø®Ø±ÙˆØ¬ÛŒ Ø±Ø§ Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯."""
        print("\n" + "="*40)
        print(f"ğŸ“ Ø°Ø®ÛŒØ±Ù‡ {len(self.raw_configs)} Ú©Ø§Ù†ÙÛŒÚ¯ Ø®Ø§Ù… Ø¯Ø± ÙØ§ÛŒÙ„ {OUTPUT_TXT}...")
        if self.raw_configs:
            with open(OUTPUT_TXT, 'w', encoding='utf-8') as f:
                # Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ Ø±Ø§ Ù…Ø±ØªØ¨ Ú©Ø±Ø¯Ù‡ Ùˆ Ø¯Ø± ÙØ§ÛŒÙ„ Ù…ÛŒâ€ŒÙ†ÙˆÛŒØ³Ø¯
                f.write("\n".join(sorted(list(self.raw_configs))))
            print("âœ… ÙØ§ÛŒÙ„ Ù…ØªÙ†ÛŒ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.")
        else:
            print("âš ï¸ Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ Ø®Ø§Ù…ÛŒ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯.")

        print(f"\nâš™ï¸ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ ÙØ§ÛŒÙ„ Ú©Ù„Ø´ ({OUTPUT_YAML})...")
        # Ù¾Ø±Ø¯Ø§Ø²Ø´ ØªÙ…Ø§Ù… Ú©Ø§Ù†ÙÛŒÚ¯â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ù… Ùˆ ØªØ¨Ø¯ÛŒÙ„ Ø¢Ù†â€ŒÙ‡Ø§ Ø¨Ù‡ ÙØ±Ù…Øª Clash
        clash_proxies = [p for p in (self.parse_config_for_clash(url) for url in self.raw_configs) if p is not None]

        if not clash_proxies:
            print(f"âš ï¸ Ù‡ÛŒÚ† Ú©Ø§Ù†ÙÛŒÚ¯ Ù…Ø¹ØªØ¨Ø±ÛŒ Ø¨Ø±Ø§ÛŒ Clash Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯. ÙØ§ÛŒÙ„ {OUTPUT_YAML} Ø®Ø§Ù„ÛŒ Ø®ÙˆØ§Ù‡Ø¯ Ø¨ÙˆØ¯.")
            open(OUTPUT_YAML, "w").close() # ÛŒÚ© ÙØ§ÛŒÙ„ Ø®Ø§Ù„ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
            return
            
        print(f"ğŸ‘ {len(clash_proxies)} Ú©Ø§Ù†ÙÛŒÚ¯ Ù…Ø¹ØªØ¨Ø± Ø¨Ø±Ø§ÛŒ Clash Ù¾ÛŒØ¯Ø§ Ø´Ø¯.")
        
        proxy_names = [p['name'] for p in clash_proxies]
        
        # Ø³Ø§Ø®ØªØ§Ø± Ù¾Ø§ÛŒÙ‡ ÙØ§ÛŒÙ„ YAML Ø¨Ø±Ø§ÛŒ Clash
        clash_config_base = {
            'port': 7890, 'socks-port': 7891, 'allow-lan': True, 'mode': 'rule',
            'log-level': 'info', 'external-controller': '127.0.0.1:9090',
            'dns': {
                'enable': True, 'listen': '0.0.0.0:53',
                'default-nameserver': ['8.8.8.8', '1.1.1.1'],
                'enhanced-mode': 'fake-ip', 'fake-ip-range': '198.18.0.1/16',
                'fallback': ['https://cloudflare-dns.com/dns-query', 'https://dns.google/dns-query'],
                'fallback-filter': {'geoip': True, 'ipcidr': ['240.0.0.0/4']}
            },
            'proxies': clash_proxies,
            'proxy-groups': [
                {'name': 'PROXY', 'type': 'select', 'proxies': ['AUTO', 'DIRECT', *proxy_names]},
                {'name': 'AUTO', 'type': 'url-test', 'proxies': proxy_names, 'url': 'http://www.gstatic.com/generate_204', 'interval': 300}
            ],
            'rules': [
                'DOMAIN-SUFFIX,local,DIRECT', 'IP-CIDR,127.0.0.0/8,DIRECT',
                'IP-CIDR,192.168.0.0/16,DIRECT', 'IP-CIDR,172.16.0.0/12,DIRECT',
                'IP-CIDR,10.0.0.0/8,DIRECT', 'GEOIP,IR,DIRECT', 'MATCH,PROXY'
            ]
        }
        
        # Ø°Ø®ÛŒØ±Ù‡ ÙØ§ÛŒÙ„ YAML Ø¨Ø§ ÙØ±Ù…Øª Ø®ÙˆØ§Ù†Ø§
        with open(OUTPUT_YAML, 'w', encoding='utf-8') as f:
            yaml.dump(clash_config_base, f, allow_unicode=True, sort_keys=False, indent=2, width=1000)
        print(f"âœ… ÙØ§ÛŒÙ„ {OUTPUT_YAML} Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯.")


async def main():
    """ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ú©Ù„ ÙØ±Ø¢ÛŒÙ†Ø¯."""
    print("ğŸš€ Ø´Ø±ÙˆØ¹ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ú©Ø§Ù†ÙÛŒÚ¯...")
    extractor = V2RayExtractor()
    async with extractor.client:
        tasks = [extractor.find_raw_configs_from_chat(channel, CHANNEL_SEARCH_LIMIT) for channel in CHANNELS]
        tasks.extend(extractor.find_raw_configs_from_chat(group, GROUP_SEARCH_LIMIT) for group in GROUPS)
        
        if tasks:
            # Ø§Ø¬Ø±Ø§ÛŒ Ù‡Ù…Ø²Ù…Ø§Ù† ØªÙ…Ø§Ù… ÙˆØ¸Ø§ÛŒÙ Ø¬Ø³ØªØ¬Ùˆ
            await asyncio.gather(*tasks)
        else:
            print("âŒ Ù‡ÛŒÚ† Ú©Ø§Ù†Ø§Ù„ ÛŒØ§ Ú¯Ø±ÙˆÙ‡ÛŒ Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ ØªØ¹Ø±ÛŒÙ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.")
    
    # Ù¾Ø³ Ø§Ø² Ø§ØªÙ…Ø§Ù… Ø¬Ø³ØªØ¬ÙˆØŒ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ Ø±Ø§ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†
    extractor.save_files()
    print("\nâœ¨ ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ù¾Ø§ÛŒØ§Ù† Ø±Ø³ÛŒØ¯!")


if __name__ == "__main__":
    # Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø¬Ø±Ø§ØŒ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ Ø¢ÛŒØ§ Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯ ÛŒØ§ Ø®ÛŒØ±
    if not all([API_ID, API_HASH, SESSION_STRING]):
        print("âŒ Ø®Ø·Ø§: ÛŒÚ© ÛŒØ§ Ú†Ù†Ø¯ Ù…ÙˆØ±Ø¯ Ø§Ø² Ø³Ú©Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ (API_ID, API_HASH, SESSION_STRING) ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.")
    else:
        # Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¨Ù‡ ØµÙˆØ±Øª Ø¢Ø³Ù†Ú©Ø±ÙˆÙ†
        asyncio.run(main())
